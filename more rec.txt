{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"isPrime": {
	"prefix": "isPrime",
	"body": [
	"bool isPrime(int n)",
"{",
    "if (n <= 1) return false;",
    "if (n <= 3) return true;",
   "if (n % 2 == 0 || n % 3 == 0)",
        "return false;",
    "for (int i = 5; i * i <= n; i = i + 6)",
        "if (n % i == 0 || n % (i + 2) == 0)",
            "return false;",
    "return true;",
"}",
	],
"description": "Log output to console"
},

"sieve": {
	"prefix": "sieve",
	"body": [
		"void SieveOfEratosthenes(int n)",
		"{",
			"bool prime[n + 1];",
			"memset(prime, true, sizeof(prime));",
		 
			"for (int p = 2; p * p <= n; p++) {",
				"if (prime[p] == true) {",
					"for (int i = p * p; i <= n; i += p)",
						"prime[i] = false;",
				"}",
			"}",
		"}",
	],
"description": "Log output to console"
},
"IterativeMergeSort": {
	"prefix": "IterativeMergeSort",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "void merge(int arr[], int l, int m, int r);",
	  "",
	  "",
	  "void mergeSort(int arr[], int l, int r)",
	  "{",
	  "if(l < r)",
	  "{",
	  "",
	  "",
	  "int m = l + (r - l) / 2;",
	  "mergeSort(arr, l, m);",
	  "mergeSort(arr, m + 1, r);",
	  "merge(arr, l, m, r);",
	  "}",
	  "}",
	  "",
	  "",
	  "void merge(int arr[], int l, int m, int r)",
	  "{",
	  "int k;",
	  "int n1 = m - l + 1;",
	  "int n2 = r - m;",
	  "",
	  "",
	  "int L[n1], R[n2];",
	  "",
	  "",
	  "for(int i = 0; i < n1; i++)",
	  "L[i] = arr[l + i];",
	  "for(int j = 0; j < n2; j++)",
	  "R[j] = arr[m + 1+ j];",
	  "",
	  "",
	  "int i = 0;",
	  "int j = 0;",
	  "k = l;",
	  "",
	  "while (i < n1 && j < n2)",
	  "{",
	  "if (L[i] <= R[j])",
	  "{",
	  "arr[k] = L[i];",
	  "i++;",
	  "}",
	  "else",
	  "{",
	  "arr[k] = R[j];",
	  "j++;",
	  "}",
	  "k++;",
	  "}",
	  "",
	  "while (i < n1)",
	  "{",
	  "arr[k] = L[i];",
	  "i++;",
	  "k++;",
	  "}",
	  "",
	  "while (j < n2)",
	  "{",
	  "arr[k] = R[j];",
	  "j++;",
	  "k++;",
	  "}",
	  "}",
	  "",
	  "",
	  "void printArray(int A[], int size)",
	  "{",
	  "for(int i = 0; i < size; i++)",
	  "printf(\"%d \", A[i]);",
	  "",
	  "cout << \"\\n\";",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 12, 11, 13, 5, 6, 7 };",
	  "int arr_size = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "cout << \"Given array is \\n\";",
	  "printArray(arr, arr_size);",
	  "",
	  "mergeSort(arr, 0, arr_size - 1);",
	  "",
	  "cout << \"\\nSorted array is \\n\";",
	  "printArray(arr, arr_size);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "RecursiveMergeSort": {
	"prefix": "RecursiveMergeSort",
	"body": [
	  "",
	  "#include <iostream>",
	  "using namespace std;",
	  "",
	  "",
	  "void merge(int array[], int const left, int const mid,",
	  "int const right)",
	  "{",
	  "auto const subArrayOne = mid - left + 1;",
	  "auto const subArrayTwo = right - mid;",
	  "",
	  "",
	  "auto *leftArray = new int[subArrayOne],",
	  "*rightArray = new int[subArrayTwo];",
	  "",
	  "",
	  "for (auto i = 0; i < subArrayOne; i++)",
	  "leftArray[i] = array[left + i];",
	  "for (auto j = 0; j < subArrayTwo; j++)",
	  "rightArray[j] = array[mid + 1 + j];",
	  "",
	  "auto indexOfSubArrayOne",
	  "= 0,",
	  "indexOfSubArrayTwo",
	  "= 0;",
	  "int indexOfMergedArray",
	  "= left;",
	  "",
	  "",
	  "while (indexOfSubArrayOne < subArrayOne",
	  "&& indexOfSubArrayTwo < subArrayTwo) {",
	  "if (leftArray[indexOfSubArrayOne]",
	  "<= rightArray[indexOfSubArrayTwo]) {",
	  "array[indexOfMergedArray]",
	  "= leftArray[indexOfSubArrayOne];",
	  "indexOfSubArrayOne++;",
	  "}",
	  "else {",
	  "array[indexOfMergedArray]",
	  "= rightArray[indexOfSubArrayTwo];",
	  "indexOfSubArrayTwo++;",
	  "}",
	  "indexOfMergedArray++;",
	  "}",
	  "",
	  "while (indexOfSubArrayOne < subArrayOne) {",
	  "array[indexOfMergedArray]",
	  "= leftArray[indexOfSubArrayOne];",
	  "indexOfSubArrayOne++;",
	  "indexOfMergedArray++;",
	  "}",
	  "",
	  "while (indexOfSubArrayTwo < subArrayTwo) {",
	  "array[indexOfMergedArray]",
	  "= rightArray[indexOfSubArrayTwo];",
	  "indexOfSubArrayTwo++;",
	  "indexOfMergedArray++;",
	  "}",
	  "delete[] leftArray;",
	  "delete[] rightArray;",
	  "}",
	  "",
	  "",
	  "void mergeSort(int array[], int const begin, int const end)",
	  "{",
	  "if (begin >= end)",
	  "return; ",
	  "",
	  "auto mid = begin + (end - begin) / 2;",
	  "mergeSort(array, begin, mid);",
	  "mergeSort(array, mid + 1, end);",
	  "merge(array, begin, mid, end);",
	  "}",
	  "",
	  "",
	  "void printArray(int A[], int size)",
	  "{",
	  "for (auto i = 0; i < size; i++)",
	  "cout << A[i] << \" \";",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 12, 11, 13, 5, 6, 7 };",
	  "auto arr_size = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "cout << \"Given array is \\n\";",
	  "printArray(arr, arr_size);",
	  "",
	  "mergeSort(arr, 0, arr_size - 1);",
	  "",
	  "cout << \"\\nSorted array is \\n\";",
	  "printArray(arr, arr_size);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "QuickSort": {
	"prefix": "QuickSort",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "void swap(int* a, int* b)",
	  "{",
	  "int t = *a;",
	  "*a = *b;",
	  "*b = t;",
	  "}",
	  "",
	  "",
	  "int partition(int arr[], int low, int high)",
	  "{",
	  "int pivot = arr[high]; ",
	  "int i",
	  "= (low",
	  "- 1); ",
	  "",
	  "",
	  "for (int j = low; j <= high - 1; j++) {",
	  "",
	  "if (arr[j] < pivot) {",
	  "i++; ",
	  "swap(&arr[i], &arr[j]);",
	  "}",
	  "}",
	  "swap(&arr[i + 1], &arr[high]);",
	  "return (i + 1);",
	  "}",
	  "",
	  "",
	  "void quickSort(int arr[], int low, int high)",
	  "{",
	  "if (low < high) {",
	  "",
	  "int pi = partition(arr, low, high);",
	  "",
	  "",
	  "quickSort(arr, low, pi - 1);",
	  "quickSort(arr, pi + 1, high);",
	  "}",
	  "}",
	  "",
	  "",
	  "void printArray(int arr[], int size)",
	  "{",
	  "int i;",
	  "for (i = 0; i < size; i++)",
	  "cout << arr[i] << \" \";",
	  "cout << endl;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 10, 7, 8, 9, 1, 5 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "quickSort(arr, 0, n - 1);",
	  "cout << \"Sorted array: \\n\";",
	  "printArray(arr, n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "CountingSort": {
	"prefix": "CountingSort",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "#include <string.h>",
	  "using namespace std;",
	  "#define RANGE 255",
	  "",
	  "",
	  "void countSort(char arr[])",
	  "{",
	  "",
	  "char output[strlen(arr)];",
	  "",
	  "",
	  "int count[RANGE + 1], i;",
	  "memset(count, 0, sizeof(count));",
	  "",
	  "",
	  "for (i = 0; arr[i]; ++i)",
	  "++count[arr[i]];",
	  "",
	  "",
	  "for (i = 1; i <= RANGE; ++i)",
	  "count[i] += count[i - 1];",
	  "",
	  "for (i = 0; arr[i]; ++i) {",
	  "output[count[arr[i]] - 1] = arr[i];",
	  "--count[arr[i]];",
	  "}",
	  "",
	  "",
	  "",
	  "for (i = 0; arr[i]; ++i)",
	  "arr[i] = output[i];",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "char arr[] = \"geeksforgeeks\";",
	  "",
	  "countSort(arr);",
	  "",
	  "cout << \"Sorted character array is \" << arr;",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Sortingelementsbyfrequency": {
	"prefix": "Sortingelementsbyfrequency",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "struct ele {",
	  "int count, index, val;",
	  "};",
	  "",
	  "",
	  "bool mycomp(struct ele a, struct ele b)",
	  "{",
	  "return (a.val < b.val);",
	  "}",
	  "",
	  "bool mycomp2(struct ele a, struct ele b)",
	  "{",
	  "if (a.count != b.count)",
	  "return (a.count < b.count);",
	  "else",
	  "return a.index > b.index;",
	  "}",
	  "",
	  "void sortByFrequency(int arr[], int n)",
	  "{",
	  "struct ele element[n];",
	  "for (int i = 0; i < n; i++) {",
	  "",
	  "",
	  "element[i].index = i;",
	  "",
	  "",
	  "element[i].count = 0;",
	  "",
	  "element[i].val = arr[i];",
	  "}",
	  "",
	  "",
	  "stable_sort(element, element + n, mycomp);",
	  "",
	  "element[0].count = 1;",
	  "",
	  "for (int i = 1; i < n; i++) {",
	  "",
	  "if (element[i].val == element[i - 1].val) {",
	  "element[i].count += element[i - 1].count + 1;",
	  "",
	  "element[i - 1].count = -1;",
	  "",
	  "",
	  "element[i].index = element[i - 1].index;",
	  "}",
	  "",
	  "",
	  "else",
	  "element[i].count = 1;",
	  "}",
	  "",
	  "stable_sort(element, element + n, mycomp2);",
	  "for (int i = n - 1, index = 0; i >= 0; i--)",
	  "if (element[i].count != -1)",
	  "for (int j = 0; j < element[i].count; j++)",
	  "arr[index++] = element[i].val;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 2, 5, 2, 6, -1, 9999999, 5, 8, 8, 8 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "sortByFrequency(arr, n);",
	  "",
	  "for (int i = 0; i < n; i++)",
	  "cout << arr[i] << \" \";",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Sortarrayinwaveform": {
	"prefix": "Sortarrayinwaveform",
	"body": [
	  "",
	  "#include<iostream>",
	  "#include<algorithm>",
	  "using namespace std;",
	  "",
	  "",
	  "void swap(int *x, int *y)",
	  "{",
	  "int temp = *x;",
	  "*x = *y;",
	  "*y = temp;",
	  "}",
	  "",
	  "",
	  "void sortInWave(int arr[], int n)",
	  "{",
	  "",
	  "sort(arr, arr+n);",
	  "",
	  "for (int i=0; i<n-1; i += 2)",
	  "swap(&arr[i], &arr[i+1]);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {10, 90, 49, 2, 1, 5, 23};",
	  "int n = sizeof(arr)/sizeof(arr[0]);",
	  "sortInWave(arr, n);",
	  "for (int i=0; i<n; i++)",
	  "cout << arr[i] << \" \";",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Findingminimumlengthsortedsub-arraytosortanarray": {
	"prefix": "Findingminimumlengthsortedsub-arraytosortanarray",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "void printUnsorted(int arr[], int n)",
	  "{",
	  "int s = 0, e = n-1, i, max, min;",
	  "",
	  "for (s = 0; s < n-1; s++)",
	  "{",
	  "if (arr[s] > arr[s+1])",
	  "break;",
	  "}",
	  "if (s == n-1)",
	  "{",
	  "cout << \"The complete array is sorted\";",
	  "return;",
	  "}",
	  "",
	  "for(e = n - 1; e > 0; e--)",
	  "{",
	  "if(arr[e] < arr[e-1])",
	  "break;",
	  "}",
	  "",
	  "max = arr[s]; min = arr[s];",
	  "for(i = s + 1; i <= e; i++)",
	  "{",
	  "if(arr[i] > max)",
	  "max = arr[i];",
	  "if(arr[i] < min)",
	  "min = arr[i];",
	  "}",
	  "",
	  "for( i = 0; i < s; i++)",
	  "{",
	  "if(arr[i] > min)",
	  "{",
	  "s = i;",
	  "break;",
	  "}",
	  "}",
	  "",
	  "for( i = n -1; i >= e+1; i--)",
	  "{",
	  "if(arr[i] < max)",
	  "{",
	  "e = i;",
	  "break;",
	  "}",
	  "}",
	  "",
	  "",
	  "cout << \"The unsorted subarray which\"",
	  "<< \" makes the given array\" << endl",
	  "<< \"sorted lies between the indices \"",
	  "<< s << \" and \" << e;",
	  "return;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {10, 12, 20, 30, 25,",
	  "40, 32, 31, 35, 50, 60};",
	  "int arr_size = sizeof(arr)/sizeof(arr[0]);",
	  "printUnsorted(arr, arr_size);",
	  "getchar();",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Sortingstrings": {
	"prefix": "Sortingstrings",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "void sortString(string &str)",
	  "{",
	  "sort(str.begin(), str.end());",
	  "cout << str;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "string s = \"geeksforgeeks\";",
	  "sortString(s);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "CountdistinctpairswithdifferenceofK": {
	"prefix": "CountdistinctpairswithdifferenceofK",
	"body": [
	  "",
	  "#include <iostream>",
	  "using namespace std;",
	  "",
	  "int countPairsWithDiffK(int arr[], int n, int k)",
	  "{",
	  "int count = 0;",
	  "",
	  "for (int i = 0; i < n; i++) {",
	  "",
	  "for (int j = i + 1; j < n; j++)",
	  "if (arr[i] - arr[j] == k",
	  "|| arr[j] - arr[i] == k)",
	  "count++;",
	  "}",
	  "return count;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 1, 5, 3, 4, 2 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "int k = 3;",
	  "cout << \"Count of pairs with given diff is \"",
	  "<< countPairsWithDiffK(arr, n, k);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Maximumnumberofpartitionsthatcanbesortedindividuallytomakesorted": {
	"prefix": "Maximumnumberofpartitionsthatcanbesortedindividuallytomakesorted",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "int maxPartitions(int arr[], int n)",
	  "{",
	  "int ans = 0, max_so_far = 0;",
	  "for (int i = 0; i < n; ++i) {",
	  "",
	  "",
	  "max_so_far = max(max_so_far, arr[i]);",
	  "",
	  "if (max_so_far == i)",
	  "ans++;",
	  "}",
	  "return ans;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 1, 0, 2, 3, 4 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "cout << maxPartitions(arr, n);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Sortingallarrayelementsexceptone": {
	"prefix": "Sortingallarrayelementsexceptone",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "int sortExceptK(int arr[], int k, int n)",
	  "{",
	  "",
	  "swap(arr[k], arr[n-1]);",
	  "",
	  "",
	  "sort(arr, arr + n - 1);",
	  "",
	  "",
	  "int last = arr[n-1];",
	  "",
	  "",
	  "for (int i=n-1; i>k; i--)",
	  "arr[i] = arr[i-1];",
	  "",
	  "",
	  "arr[k] = last;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int a[] = {10, 4, 11, 7, 6, 20 };",
	  "int k = 2;",
	  "int n = sizeof(a) / sizeof(a[0]);",
	  "sortExceptK(a, k, n);",
	  "for (int i = 0; i < n; i++)",
	  "cout << a[i] << \" \";",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "RopeCutting": {
	"prefix": "RopeCutting",
	"body": [
	  "public static ArrayList<Integer> RopeCutting (int arr[], int n) {",
	  "",
	  "      ArrayList<Integer> res = new ArrayList<>();",
	  "",
	  "      ",
	  "",
	  "      Arrays.sort(arr);",
	  "",
	  "       int cuttingLen = arr[0];",
	  "",
	  "      for(int i = 0 ; i < arr.length; i++){",
	  "",
	  "         ",
	  "",
	  "          if(arr[i] - cuttingLen > 0)",
	  "",
	  "          {",
	  "",
	  "              cuttingLen = arr[i];",
	  "",
	  "              res.add(n-i);",
	  "",
	  "          }",
	  "",
	  "      }",
	  "",
	  "      return res;",
	  "",
	  "    }"
	],
	"description": "Log output to console"
  },
  
  "MergekSortedArrays": {
	"prefix": "MergekSortedArrays",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "#define N 4",
	  "",
	  "void printArray(int arr[], int size)",
	  "{",
	  "for (int i = 0; i < size; i++)",
	  "cout << arr[i] << \" \";",
	  "}",
	  "",
	  "void mergeKArrays(int arr[][N], int a, int output[])",
	  "{",
	  "int c = 0;",
	  "",
	  "for (int i = 0; i < a; i++) {",
	  "for (int j = 0; j < N; j++)",
	  "output = arr[i][j];",
	  "}",
	  "",
	  "sort(output, output + N * a);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "",
	  "int arr[][N] = { { 2, 6, 12, 34 },",
	  "{ 1, 9, 20, 1000 },",
	  "{ 23, 34, 90, 2000 } };",
	  "int K = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "int output[N * K];",
	  "",
	  "mergeKArrays(arr, 3, output);",
	  "",
	  "cout << \"Merged array is \" << endl;",
	  "printArray(output, N * K);",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Findallfoursumnumbers": {
	"prefix": "Findallfoursumnumbers",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "class pairSum {",
	  "public:",
	  "",
	  "int first;",
	  "",
	  "int sec;",
	  "",
	  "int sum;",
	  "};",
	  "",
	  "",
	  "int compare(const void* a, const void* b)",
	  "{",
	  "return ((*(pairSum*)a).sum - (*(pairSum*)b).sum);",
	  "}",
	  "",
	  "",
	  "bool noCommon(pairSum a, pairSum b)",
	  "{",
	  "if (a.first == b.first || a.first == b.sec",
	  "|| a.sec == b.first || a.sec == b.sec)",
	  "return false;",
	  "return true;",
	  "}",
	  "",
	  "void findFourElements(int arr[], int n, int X)",
	  "{",
	  "int i, j;",
	  "",
	  "",
	  "int size = (n * (n - 1)) / 2;",
	  "pairSum aux[size];",
	  "",
	  "",
	  "int k = 0;",
	  "for (i = 0; i < n - 1; i++) {",
	  "for (j = i + 1; j < n; j++) {",
	  "aux[k].sum = arr[i] + arr[j];",
	  "aux[k].first = i;",
	  "aux[k].sec = j;",
	  "k++;",
	  "}",
	  "}",
	  "",
	  "qsort(aux, size, sizeof(aux[0]), compare);",
	  "",
	  "",
	  "i = 0;",
	  "j = size - 1;",
	  "while (i < size && j >= 0) {",
	  "if ((aux[i].sum + aux[j].sum == X)",
	  "&& noCommon(aux[i], aux[j])) {",
	  "cout << arr[aux[i].first] << \", \"",
	  "<< arr[aux[i].sec] << \", \"",
	  "<< arr[aux[j].first] << \", \"",
	  "<< arr[aux[j].sec] << endl;",
	  "return;",
	  "}",
	  "else if (aux[i].sum + aux[j].sum < X)",
	  "i++;",
	  "else",
	  "j--;",
	  "}",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 10, 20, 30, 40, 1, 2 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "int X = 91;",
	  "",
	  "findFourElements(arr, n, X);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "MaximumIntervalsOverlap": {
	"prefix": "MaximumIntervalsOverlap",
	"body": [
	  "",
	  "#include<iostream>",
	  "#include<algorithm>",
	  "using namespace std;",
	  "",
	  "void findMaxGuests(int arrl[], int exit[], int n)",
	  "{",
	  "",
	  "sort(arrl, arrl+n);",
	  "sort(exit, exit+n);",
	  "",
	  "int guests_in = 1, max_guests = 1, time = arrl[0];",
	  "int i = 1, j = 0;",
	  "",
	  "while (i < n && j < n)",
	  "{",
	  "",
	  "if (arrl[i] <= exit[j])",
	  "{",
	  "guests_in++;",
	  "",
	  "if (guests_in > max_guests)",
	  "{",
	  "max_guests = guests_in;",
	  "time = arrl[i];",
	  "}",
	  "i++; //increment index of arrival array",
	  "}",
	  "else ",
	  "{ ",
	  "guests_in--;",
	  "j++;",
	  "}",
	  "}",
	  "",
	  "cout << \"Maximum Number of Guests = \" << max_guests",
	  "<< \" at time \" << time;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arrl[] = {1, 2, 10, 5, 5};",
	  "int exit[] = {4, 5, 12, 9, 12};",
	  "int n = sizeof(arrl)/sizeof(arrl[0]);",
	  "findMaxGuests(arrl, exit, n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "MarksofPCM": {
	"prefix": "MarksofPCM",
	"body": [
	  "class Node:",
	  "    def __init__(self,phy,chem,maths):",
	  "        self.phy=phy",
	  "        self.chem=chem",
	  "        self.maths=maths",
	  "    def __gt__(self,other):",
	  "        if(self.phy<other.phy):",
	  "            return False",
	  "        elif(self.phy>other.phy):",
	  "            return True",
	  "        if(self.chem<other.chem):",
	  "            return True",
	  "        elif(self.chem>other.chem):",
	  "            return False",
	  "        if(self.maths<other.maths):",
	  "            return False",
	  "        elif(self.maths>other.maths):",
	  "            return True",
	  "        else:return False",
	  "        ",
	  "class Solution:",
	  "    def customSort(self, phy, chem, math, N):",
	  "        # code here",
	  "        new=[]",
	  "        for i in range(N):",
	  "            new.append(Node(phy[i],chem[i],maths[i]))",
	  "        new.sort()",
	  "        for i in range(N):",
	  "            phy[i]=new[i].phy",
	  "            chem[i]=new[i].chem",
	  "            maths[i]=new[i].maths"
	],
	"description": "Log output to console"
  },
  
  "Case-specificSortingofStrings": {
	"prefix": "Case-specificSortingofStrings",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "string getSortedString(string s, int n)",
	  "{",
	  "",
	  "vector<char> v1, v2;",
	  "for (int i = 0; i < n; i++) {",
	  "if (s[i] >= 'a' && s[i] <= 'z')",
	  "v1.push_back(s[i]);",
	  "if (s[i] >= 'A' && s[i] <= 'Z')",
	  "v2.push_back(s[i]);",
	  "}",
	  "",
	  "",
	  "sort(v1.begin(), v1.end());",
	  "sort(v2.begin(), v2.end());",
	  "int i = 0, j = 0;",
	  "for (int k = 0; k < n; k++) {",
	  "",
	  "if (s[k] >= 'a' && s[k] <= 'z') {",
	  "s[k] = v1[i];",
	  "++i;",
	  "}",
	  "",
	  "",
	  "else if (s[k] >= 'A' && s[k] <= 'Z') {",
	  "s[k] = v2[j];",
	  "++j;",
	  "}",
	  "}",
	  "",
	  "",
	  "return s;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "string s = \"gEeksfOrgEEkS\";",
	  "int n = s.length();",
	  "",
	  "cout << getSortedString(s, n);",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "PrintBinaryTreelevelsinsortedorder": {
	"prefix": "PrintBinaryTreelevelsinsortedorder",
	"body": [
	  "",
	  "#include <iostream>",
	  "#include <queue>",
	  "#include <vector>",
	  "using namespace std;",
	  "",
	  "",
	  "struct Node {",
	  "int data;",
	  "struct Node *left, *right;",
	  "};",
	  "",
	  "",
	  "void printLevelOrder(Node* root)",
	  "{",
	  "",
	  "if (root == NULL)",
	  "return;",
	  "",
	  "",
	  "queue<Node*> q;",
	  "",
	  "priority_queue<int, vector<int>, greater<int> > current_level;",
	  "",
	  "priority_queue<int, vector<int>, greater<int> > next_level;",
	  "",
	  "",
	  "q.push(root);",
	  "",
	  "",
	  "q.push(NULL);",
	  "",
	  "current_level.push(root->data);",
	  "",
	  "while (q.empty() == false) {",
	  "",
	  "",
	  "int data = current_level.top();",
	  "",
	  "Node* node = q.front();",
	  "",
	  "if (node == NULL) {",
	  "q.pop();",
	  "",
	  "if (q.empty())",
	  "break;",
	  "",
	  "q.push(NULL);",
	  "cout << \"\\n\";",
	  "",
	  "current_level.swap(next_level);",
	  "",
	  "continue;",
	  "}",
	  "",
	  "cout << data << \" \";",
	  "",
	  "q.pop();",
	  "current_level.pop();",
	  "",
	  "if (node->left != NULL) {",
	  "q.push(node->left);",
	  "",
	  "",
	  "next_level.push(node->left->data);",
	  "}",
	  "",
	  "if (node->right != NULL) {",
	  "q.push(node->right);",
	  "",
	  "",
	  "next_level.push(node->right->data);",
	  "}",
	  "}",
	  "}",
	  "",
	  "Node* newNode(int data)",
	  "{",
	  "Node* temp = new Node;",
	  "temp->data = data;",
	  "temp->left = temp->right = NULL;",
	  "return temp;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "",
	  "Node* root = newNode(7);",
	  "root->left = newNode(6);",
	  "root->right = newNode(5);",
	  "root->left->left = newNode(4);",
	  "root->left->right = newNode(3);",
	  "root->right->left = newNode(2);",
	  "root->right->right = newNode(1);",
	  "",
	  "cout << \"Level Order traversal of binary tree is \\n\";",
	  "printLevelOrder(root);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "MinimumSwapstoSort": {
	"prefix": "MinimumSwapstoSort",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "",
	  "using namespace std;",
	  "",
	  "",
	  "int minSwaps(int arr[], int n)",
	  "{",
	  "",
	  "pair<int, int> arrPos[n];",
	  "for (int i = 0; i < n; i++)",
	  "{",
	  "arrPos[i].first = arr[i];",
	  "arrPos[i].second = i;",
	  "}",
	  "",
	  "sort(arrPos, arrPos + n);",
	  "",
	  "vector<bool> vis(n, false);",
	  "",
	  "int ans = 0;",
	  "",
	  "for (int i = 0; i < n; i++)",
	  "{",
	  "",
	  "if (vis[i] || arrPos[i].second == i)",
	  "continue;",
	  "",
	  "int cycle_size = 0;",
	  "int j = i;",
	  "while (!vis[j])",
	  "{",
	  "vis[j] = 1;",
	  "",
	  "j = arrPos[j].second;",
	  "cycle_size++;",
	  "}",
	  "",
	  "if (cycle_size > 0)",
	  "{",
	  "ans += (cycle_size - 1);",
	  "}",
	  "}",
	  "",
	  "return ans;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {1, 5, 4, 3, 2};",
	  "int n = (sizeof(arr) / sizeof(int));",
	  "cout << minSwaps(arr, n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  "LIS": {
	"prefix": "LIS",
	"body": [
	  "#include <iostream>",
	  "using namespace std;",
	  "",
	  "int _lis(int arr[], int n, int* max_ref)",
	  "{",
	  "if (n == 1)",
	  "return 1;",
	  "",
	  "int res, max_ending_here = 1;",
	  "for (int i = 1; i < n; i++) {",
	  "res = _lis(arr, i, max_ref);",
	  "if (arr[i - 1] < arr[n - 1]",
	  "&& res + 1 > max_ending_here)",
	  "max_ending_here = res + 1;",
	  "}",
	  "",
	  "if (*max_ref < max_ending_here)",
	  "*max_ref = max_ending_here;",
	  "",
	  "",
	  "return max_ending_here;",
	  "}",
	  "",
	  "",
	  "int lis(int arr[], int n)",
	  "{",
	  "",
	  "int max = 1;",
	  "",
	  "",
	  "_lis(arr, n, &max);",
	  "",
	  "",
	  "return max;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "cout <<\"Length of lis is \"<< lis(arr, n);",
	  "return 0;",
	  "}",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  
   
  "LCS": {
	"prefix": "LCS",
	"body": [
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int lcs( char *X, char *Y, int m, int n )",
	  "{",
	  "if (m == 0 || n == 0)",
	  "return 0;",
	  "if (X[m-1] == Y[n-1])",
	  "return 1 + lcs(X, Y, m-1, n-1);",
	  "else",
	  "return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));",
	  "}",
	  "",
	  "",
	  "",
	  "",
	  "int main()",
	  "{",
	  "char X[] = \"AGGTAB\";",
	  "char Y[] = \"GXTXAYB\";",
	  "",
	  "int m = strlen(X);",
	  "int n = strlen(Y);",
	  "",
	  "cout<<\"Length of LCS is \"<< lcs( X, Y, m, n ) ;",
	  "",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "BinomialCoefficient": {
	"prefix": "BinomialCoefficient",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int binomialCoeff(int n, int k)",
	  "{",
	  "if (k > n)",
	  "return 0;",
	  "if (k == 0 || k == n)",
	  "return 1;",
	  "",
	  "",
	  "return binomialCoeff(n - 1, k - 1)",
	  "+ binomialCoeff(n - 1, k);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int n = 5, k = 2;",
	  "cout << \"Value of C(\" << n << \", \" << k << \") is \"",
	  "<< binomialCoeff(n, k);",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "BoxStacking": {
	"prefix": "BoxStacking",
	"body": [
	  "",
	  "#include<stdio.h>",
	  "#include<stdlib.h>",
	  "",
	  "",
	  "struct Box",
	  "{",
	  "",
	  "int h, w, d; // for simplicity of solution, always keep w <= d",
	  "};",
	  "",
	  "",
	  "int min (int x, int y)",
	  "{ return (x < y)? x : y; }",
	  "",
	  "",
	  "int max (int x, int y)",
	  "{ return (x > y)? x : y; }",
	  "",
	  "",
	  "int compare (const void *a, const void * b)",
	  "{",
	  "return ( (*(Box *)b).d * (*(Box *)b).w ) -",
	  "( (*(Box *)a).d * (*(Box *)a).w );",
	  "}",
	  "",
	  "",
	  "int maxStackHeight( Box arr[], int n )",
	  "{",
	  "",
	  "Box rot[3*n];",
	  "int index = 0;",
	  "for (int i = 0; i < n; i++)",
	  "{",
	  "",
	  "rot[index].h = arr[i].h;",
	  "rot[index].d = max(arr[i].d, arr[i].w);",
	  "rot[index].w = min(arr[i].d, arr[i].w);",
	  "index++;",
	  "",
	  "",
	  "rot[index].h = arr[i].w;",
	  "rot[index].d = max(arr[i].h, arr[i].d);",
	  "rot[index].w = min(arr[i].h, arr[i].d);",
	  "index++;",
	  "",
	  "",
	  "rot[index].h = arr[i].d;",
	  "rot[index].d = max(arr[i].h, arr[i].w);",
	  "rot[index].w = min(arr[i].h, arr[i].w);",
	  "index++;",
	  "}",
	  "",
	  "",
	  "n = 3*n;",
	  "",
	  "",
	  "qsort (rot, n, sizeof(rot[0]), compare);",
	  "",
	  "",
	  "",
	  "int msh[n];",
	  "for (int i = 0; i < n; i++ )",
	  "msh[i] = rot[i].h;",
	  "",
	  "",
	  "for (int i = 1; i < n; i++ )",
	  "for (int j = 0; j < i; j++ )",
	  "if ( rot[i].w < rot[j].w &&",
	  "rot[i].d < rot[j].d &&",
	  "msh[i] < msh[j] + rot[i].h",
	  ")",
	  "{",
	  "msh[i] = msh[j] + rot[i].h;",
	  "}",
	  "",
	  "",
	  "",
	  "int max = -1;",
	  "for ( int i = 0; i < n; i++ )",
	  "if ( max < msh[i] )",
	  "max = msh[i];",
	  "",
	  "return max;",
	  "}",
	  "",
	  "int main()",
	  "{",
	  "Box arr[] = { {4, 6, 7}, {1, 2, 3}, {4, 5, 6}, {10, 12, 32} };",
	  "int n = sizeof(arr)/sizeof(arr[0]);",
	  "",
	  "printf(\"The maximum possible height of stack is %d\\n\",",
	  "maxStackHeight (arr, n) );",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "IntegerKnapsackProblem": {
	"prefix": "IntegerKnapsackProblem",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int max(int a, int b) { return (a > b) ? a : b; }",
	  "",
	  "",
	  "int knapSack(int W, int wt[], int val[], int n)",
	  "{",
	  "",
	  "",
	  "if (n == 0 || W == 0)",
	  "return 0;",
	  "",
	  "",
	  "if (wt[n - 1] > W)",
	  "return knapSack(W, wt, val, n - 1);",
	  "",
	  "",
	  "else",
	  "return max(",
	  "val[n - 1]",
	  "+ knapSack(W - wt[n - 1],",
	  "wt, val, n - 1),",
	  "knapSack(W, wt, val, n - 1));",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int val[] = { 60, 100, 120 };",
	  "int wt[] = { 10, 20, 30 };",
	  "int W = 50;",
	  "int n = sizeof(val) / sizeof(val[0]);",
	  "cout << knapSack(W, wt, val, n);",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "EditDistance": {
	"prefix": "EditDistance",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int min(int x, int y, int z) { return min(min(x, y), z); }",
	  "",
	  "int editDist(string str1, string str2, int m, int n)",
	  "{",
	  "",
	  "if (m == 0)",
	  "return n;",
	  "",
	  "",
	  "if (n == 0)",
	  "return m;",
	  "",
	  "",
	  "if (str1[m - 1] == str2[n - 1])",
	  "return editDist(str1, str2, m - 1, n - 1);",
	  "",
	  "",
	  "return 1",
	  "+ min(editDist(str1, str2, m, n - 1), ",
	  "editDist(str1, str2, m - 1, n), ",
	  "editDist(str1, str2, m - 1,",
	  "n - 1) ",
	  ");",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "",
	  "string str1 = \"sunday\";",
	  "string str2 = \"saturday\";",
	  "",
	  "cout << editDist(str1, str2, str1.length(),",
	  "str2.length());",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "BalancedPartition": {
	"prefix": "BalancedPartition",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "bool isSubsetSum(int arr[], int n, int sum)",
	  "{",
	  "",
	  "if (sum == 0)",
	  "return true;",
	  "if (n == 0 && sum != 0)",
	  "return false;",
	  "",
	  "",
	  "if (arr[n - 1] > sum)",
	  "return isSubsetSum(arr, n - 1, sum);",
	  "",
	  "return isSubsetSum(arr, n - 1, sum)",
	  "|| isSubsetSum(arr, n - 1, sum - arr[n - 1]);",
	  "}",
	  "",
	  "",
	  "bool findPartiion(int arr[], int n)",
	  "{",
	  "",
	  "int sum = 0;",
	  "for (int i = 0; i < n; i++)",
	  "sum += arr[i];",
	  "",
	  "",
	  "if (sum % 2 != 0)",
	  "return false;",
	  "",
	  "",
	  "return isSubsetSum(arr, n, sum / 2);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 3, 1, 5, 9, 12 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "",
	  "if (findPartiion(arr, n) == true)",
	  "cout << \"Can be divided into two subsets \"",
	  "\"of equal sum\";",
	  "else",
	  "cout << \"Can not be divided into two subsets\"",
	  "\" of equal sum\";",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "CheckifanyvalidsequenceisdivisiblebyM": {
	"prefix": "CheckifanyvalidsequenceisdivisiblebyM",
	"body": [
	  "bool isPossible(int index, int sum)",
	  "{",
	  "",
	  "if (index == n) {",
	  "",
	  "",
	  "if ((sum % M) == 0)",
	  "return true;",
	  "return false;",
	  "}",
	  "",
	  "",
	  "",
	  "",
	  "bool placeAdd = isPossible(index + 1,",
	  "sum + arr[index]);",
	  "",
	  "",
	  "bool placeMinus = isPossible(index + 1,",
	  "sum - arr[index]);",
	  "",
	  "if (placeAdd || placeMinus)",
	  "return true;",
	  "",
	  "return false;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "LCSof'0'KRepeatedString": {
	"prefix": "LCSof'0'KRepeatedString",
	"body": [
	  "",
	  "#include <cstdlib>",
	  "#include <cstring>",
	  "#include <iostream>",
	  "using namespace std;",
	  "",
	  "",
	  "void lcs(char* X, char* Y, int m, int n)",
	  "{",
	  "int L[m + 1][n + 1];",
	  "",
	  "",
	  "for (int i = 0; i <= m; i++) {",
	  "for (int j = 0; j <= n; j++) {",
	  "if (i == 0 || j == 0)",
	  "L[i][j] = 0;",
	  "else if (X[i - 1] == Y[j - 1])",
	  "L[i][j] = L[i - 1][j - 1] + 1;",
	  "else",
	  "L[i][j] = max(L[i - 1][j], L[i][j - 1]);",
	  "}",
	  "}",
	  "",
	  "",
	  "int index = L[m][n];",
	  "",
	  "",
	  "char lcs[index + 1];",
	  "lcs[index] = '\\0'; // Set the terminating character",
	  "",
	  "int i = m, j = n;",
	  "while (i > 0 && j > 0) {",
	  "",
	  "if (X[i - 1] == Y[j - 1]) {",
	  "lcs[index - 1]",
	  "= X[i - 1]; // Put current character in result",
	  "i--;",
	  "j--;",
	  "index--; // reduce values of i, j and index",
	  "}",
	  "",
	  "",
	  "else if (L[i - 1][j] > L[i][j - 1])",
	  "i--;",
	  "else",
	  "j--;",
	  "}",
	  "",
	  "",
	  "cout << \"LCS of \" << X << \" and \" << Y << \" is \" << lcs;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "char X[] = \"AGGTAB\";",
	  "char Y[] = \"GXTXAYB\";",
	  "int m = strlen(X);",
	  "int n = strlen(Y);",
	  "lcs(X, Y, m, n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Minimumnumberofdeletionsandinsertions": {
	"prefix": "Minimumnumberofdeletionsandinsertions",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "",
	  "using namespace std;",
	  "",
	  "",
	  "int lcs(string str1, string str2, int m, int n)",
	  "{",
	  "int L[m + 1][n + 1];",
	  "int i, j;",
	  "",
	  "",
	  "for (i = 0; i <= m; i++) {",
	  "for (j = 0; j <= n; j++) {",
	  "if (i == 0 || j == 0)",
	  "L[i][j] = 0;",
	  "",
	  "else if (str1.at(i - 1) == str2.at(j - 1))",
	  "L[i][j] = L[i - 1][j - 1] + 1;",
	  "",
	  "else",
	  "L[i][j] = max(L[i - 1][j], L[i][j - 1]);",
	  "}",
	  "}",
	  "",
	  "",
	  "return L[m][n];",
	  "}",
	  "",
	  "void printMinDelAndInsert(string str1, string str2)",
	  "{",
	  "int m = str1.size();",
	  "int n = str2.size();",
	  "",
	  "int len = lcs(str1, str2, m, n);",
	  "",
	  "cout << \"Minimum number of deletions = \" << (m - len)",
	  "<< endl;",
	  "",
	  "cout << \"Minimum number of insertions = \" << (n - len)",
	  "<< endl;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "string str1 = \"heap\";",
	  "string str2 = \"pea\";",
	  "",
	  "",
	  "printMinDelAndInsert(str1, str2);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Minimuminsertionstosortanarray": {
	"prefix": "Minimuminsertionstosortanarray",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int minInsertionStepToSortArray(int arr[], int N)",
	  "{",
	  "",
	  "int lis[N];",
	  "",
	  "",
	  "for (int i = 0; i < N; i++)",
	  "lis[i] = 1;",
	  "",
	  "",
	  "for (int i = 1; i < N; i++)",
	  "for (int j = 0; j < i; j++)",
	  "if (arr[i] >= arr[j] && lis[i] < lis[j] + 1)",
	  "lis[i] = lis[j] + 1;",
	  "",
	  "",
	  "",
	  "int max = 0;",
	  "for (int i = 0; i < N; i++)",
	  "if (max < lis[i])",
	  "max = lis[i];",
	  "",
	  "",
	  "return (N - max);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {2, 3, 5, 1, 4, 7, 6};",
	  "int N = sizeof(arr) / sizeof(arr[0]);",
	  "cout << minInsertionStepToSortArray(arr, N);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Countthenumberofways": {
	"prefix": "Countthenumberofways",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "",
	  "using namespace std;",
	  "",
	  "",
	  "int countWays(int n, int m)",
	  "{",
	  "",
	  "",
	  "int count[n + 1];",
	  "count[0] = 0;",
	  "",
	  "for (int i = 1; i <= n; i++) {",
	  "",
	  "",
	  "if (i > m)",
	  "count[i] = count[i - 1] + count[i - m];",
	  "",
	  "",
	  "else if (i < m || i == 1)",
	  "count[i] = 1;",
	  "",
	  "",
	  "else",
	  "count[i] = 2;",
	  "}",
	  "",
	  "",
	  "return count[n];",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int n = 7, m = 4;",
	  "cout << \"Number of ways = \"",
	  "<< countWays(n, m);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Minimumstepstodeleteastring": {
	"prefix": "Minimumstepstodeleteastring",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int helper(string str, int si, int ei,",
	  "vector<vector<int> >& dp)",
	  "{",
	  "",
	  "if (si > ei)",
	  "return 0;",
	  "",
	  "if (ei - si + 1 == 1)",
	  "return 1;",
	  "",
	  "if (dp[si][ei] != -1)",
	  "return dp[si][ei];",
	  "",
	  "",
	  "int op1 = 1e9, op2 = 1e9, op3 = 1e9;",
	  "",
	  "",
	  "op1 = 1 + helper(str, si + 1, ei, dp);",
	  "",
	  "if (str[si] == str[si + 1])",
	  "op2 = 1 + helper(str, si + 2, ei, dp);",
	  "",
	  "",
	  "for (int i = si + 2; i <= ei; i++) {",
	  "if (str[si] == str[i])",
	  "op3 = min(op3,",
	  "helper(str, si + 1, i - 1, dp)",
	  "+ helper(str, i + 1, ei, dp));",
	  "}",
	  "",
	  "",
	  "return dp[si][ei] = min({ op1, op2, op3 });",
	  "}",
	  "",
	  "int minStepToDeleteString(string s)",
	  "{",
	  "int n = s.size();",
	  "",
	  "",
	  "vector<vector<int> > dp(n, vector<int>(n, -1));",
	  "",
	  "",
	  "return helper(s, 0, n - 1, dp);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "string str = \"2553432\";",
	  "cout << minStepToDeleteString(str) << endl;",
	  "return 0;",
	  "}",
	  "",
	  "",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Subsetwithsumdivisiblebym": {
	"prefix": "Subsetwithsumdivisiblebym",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "bool helper(int N, int nums[], int sum, int idx, int m){",
	  "",
	  "if(idx == N){",
	  "",
	  "if(sum && sum%m == 0){",
	  "",
	  "return true ;",
	  "}",
	  "return false ;",
	  "}",
	  "",
	  "",
	  "bool picked = helper(N, nums, sum+nums[idx], idx+1,m) ;",
	  "bool notPicked = helper(N, nums, sum,idx+1, m) ;",
	  "",
	  "return picked || notPicked ;",
	  "}",
	  "",
	  "bool modularSum(int arr[], int n, int m)",
	  "{",
	  "return helper(n, arr, 0, 0, m) ;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {1, 7};",
	  "int n = sizeof(arr)/sizeof(arr[0]);",
	  "int m = 5;",
	  "",
	  "modularSum(arr, n, m) ? cout << \"YES\\n\" :",
	  "cout << \"NO\\n\";",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Countofstringsthatcanbeformedusinga,bandcundergivenconstraints": {
	"prefix": "Countofstringsthatcanbeformedusinga,bandcundergivenconstraints",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int countStr(int n, int bCount, int cCount)",
	  "{",
	  "",
	  "if (bCount < 0 || cCount < 0) return 0;",
	  "if (n == 0) return 1;",
	  "if (bCount == 0 && cCount == 0) return 1;",
	  "",
	  "",
	  "int res = countStr(n-1, bCount, cCount);",
	  "res += countStr(n-1, bCount-1, cCount);",
	  "res += countStr(n-1, bCount, cCount-1);",
	  "",
	  "return res;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int n = 3; ",
	  "cout << countStr(n, 1, 2);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "ShortestUncommonSubsequence": {
	"prefix": "ShortestUncommonSubsequence",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "#define MAX 1005",
	  "",
	  "",
	  "int shortestSeq(char *S, char *T, int m, int n)",
	  "{",
	  "",
	  "if (m == 0)",
	  "return MAX;",
	  "",
	  "",
	  "if (n <= 0)",
	  "return 1;",
	  "",
	  "",
	  "int k;",
	  "for (k=0; k < n; k++)",
	  "if (T[k] == S[0])",
	  "break;",
	  "",
	  "",
	  "if (k == n)",
	  "return 1;",
	  "",
	  "",
	  "return min(shortestSeq(S+1, T, m-1, n),",
	  "1 + shortestSeq(S+1, T+k+1, m-1, n-k-1));",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "char S[] = \"babab\";",
	  "char T[] = \"babba\";",
	  "int m = strlen(S), n = strlen(T);",
	  "int ans = shortestSeq(S, T, m, n);",
	  "if (ans >= MAX)",
	  "ans = -1;",
	  "cout << \"Length of shortest subsequence is: \"",
	  "<< ans << endl;",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "SizeofarrayafterrepeateddeletionofLIS": {
	"prefix": "SizeofarrayafterrepeateddeletionofLIS",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "vector<int> findLIS(vector<int> arr, int n)",
	  "{",
	  "vector <vector<int> > L(n);",
	  "",
	  "",
	  "L[0].push_back(arr[0]);",
	  "",
	  "for (int i = 1; i < n; i++)",
	  "{",
	  "",
	  "for (int j = 0; j < i; j++)",
	  "{",
	  "",
	  "if (arr[i] > arr[j] && (L[i].size() < L[j].size()))",
	  "L[i] = L[j];",
	  "}",
	  "",
	  "",
	  "L[i].push_back(arr[i]);",
	  "}",
	  "",
	  "",
	  "int maxSize = 1;",
	  "vector<int> lis;",
	  "for (vector<int> x : L)",
	  "{",
	  "",
	  "if (x.size() > maxSize)",
	  "{",
	  "lis = x;",
	  "maxSize = x.size();",
	  "}",
	  "}",
	  "",
	  "return lis;",
	  "}",
	  "",
	  "",
	  "void minimize(int input[], int n)",
	  "{",
	  "vector<int> arr(input, input + n);",
	  "",
	  "while (arr.size())",
	  "{",
	  "",
	  "vector<int> lis = findLIS(arr, arr.size());",
	  "",
	  "",
	  "if (lis.size() < 2)",
	  "break;",
	  "",
	  "",
	  "for (int i=0; i<arr.size() && lis.size()>0; i++)",
	  "{",
	  "",
	  "if (arr[i] == lis[0])",
	  "{",
	  "",
	  "arr.erase(arr.begin()+i) ;",
	  "i--;",
	  "",
	  "",
	  "lis.erase(lis.begin()) ;",
	  "}",
	  "}",
	  "}",
	  "",
	  "",
	  "int i;",
	  "for (i=0; i < arr.size(); i++)",
	  "cout << arr[i] << \" \";",
	  "",
	  "",
	  "if (i == 0)",
	  "cout << \"-1\";",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int input[] = { 3, 2, 6, 4, 5, 1 };",
	  "int n = sizeof(input) / sizeof(input[0]);",
	  "",
	  "",
	  "minimize(input, n);",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Findnumberoftimesastringoccursasasubsequence": {
	"prefix": "Findnumberoftimesastringoccursasasubsequence",
	"body": [
	  "",
	  "#include <iostream>",
	  "using namespace std;",
	  "",
	  "",
	  "int count(string a, string b, int m, int n)",
	  "{",
	  "",
	  "if ((m == 0 && n == 0) || n == 0)",
	  "return 1;",
	  "",
	  "",
	  "if (m == 0)",
	  "return 0;",
	  "",
	  "",
	  "if (a[m - 1] == b[n - 1])",
	  "return count(a, b, m - 1, n - 1) +",
	  "count(a, b, m - 1, n);",
	  "else",
	  "",
	  "return count(a, b, m - 1, n);",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "string a = \"GeeksforGeeks\";",
	  "string b = \"Gks\";",
	  "",
	  "cout << count(a, b, a.size(), b.size()) << endl;",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "PrintingMaximumSumIncreasingSubsequence": {
	"prefix": "PrintingMaximumSumIncreasingSubsequence",
	"body": [
	  "",
	  "#include <iostream>",
	  "#include <vector>",
	  "using namespace std;",
	  "",
	  "",
	  "int findSum(vector<int> arr)",
	  "{",
	  "int sum = 0;",
	  "for (int i : arr)",
	  "sum += i;",
	  "return sum;",
	  "}",
	  "",
	  "",
	  "void printMaxSumIS(int arr[], int n)",
	  "{",
	  "",
	  "vector<vector<int> > L(n);",
	  "",
	  "L[0].push_back(arr[0]);",
	  "",
	  "",
	  "for (int i = 1; i < n; i++) {",
	  "",
	  "for (int j = 0; j < i; j++) {",
	  "",
	  "where j < i and arr[j] < arr[i] */",
	  "if ((arr[i] > arr[j])",
	  "&& (findSum(L[i]) < findSum(L[j])))",
	  "L[i] = L[j];",
	  "}",
	  "",
	  "",
	  "L[i].push_back(arr[i]);",
	  "",
	  "",
	  "}",
	  "",
	  "vector<int> res = L[0];",
	  "",
	  "",
	  "for (vector<int> x : L)",
	  "if (findSum(x) > findSum(res))",
	  "res = x;",
	  "",
	  "",
	  "for (int i : res)",
	  "cout << i << \" \";",
	  "cout << endl;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = { 3, 2, 6, 4, 5, 1 };",
	  "int n = sizeof(arr) / sizeof(arr[0]);",
	  "",
	  "",
	  "printMaxSumIS(arr, n);",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "CountIncreasingSubsequence": {
	"prefix": "CountIncreasingSubsequence",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int countSub(int arr[], int n)",
	  "{",
	  "",
	  "int count[10] = {0};",
	  "",
	  "for (int i=0; i<n; i++)",
	  "{",
	  "",
	  "for (int j=arr[i]-1; j>=0; j--)",
	  "count[arr[i]] += count[j];",
	  "",
	  "",
	  "count[arr[i]]++;",
	  "}",
	  "",
	  "",
	  "int result = 0;",
	  "for (int i=0; i<10; i++)",
	  "result += count[i];",
	  "",
	  "return result;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {3, 2, 4, 5, 4};",
	  "int n = sizeof(arr)/sizeof(arr[0]);",
	  "",
	  "cout << countSub(arr,n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Pairswithspecificdifference": {
	"prefix": "Pairswithspecificdifference",
	"body": [
	  "",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int maxSumPairWithDifferenceLessThanK(int arr[], int N, int K)",
	  "{",
	  "",
	  "sort(arr, arr+N);",
	  "",
	  "",
	  "int dp[N];",
	  "",
	  "",
	  "dp[0] = 0;",
	  "",
	  "for (int i = 1; i < N; i++)",
	  "{",
	  "",
	  "dp[i] = dp[i-1];",
	  "",
	  "",
	  "if (arr[i] - arr[i-1] < K)",
	  "{",
	  "if (i >= 2)",
	  "dp[i] = max(dp[i], dp[i-2] + arr[i] + arr[i-1]);",
	  "else",
	  "dp[i] = max(dp[i], arr[i] + arr[i-1]);",
	  "}",
	  "}",
	  "",
	  "",
	  "return dp[N - 1];",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int arr[] = {3, 5, 10, 15, 17, 12, 9};",
	  "int N = sizeof(arr)/sizeof(int);",
	  "",
	  "int K = 4;",
	  "cout << maxSumPairWithDifferenceLessThanK(arr, N, K);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "MinimumnumberofCoins": {
	"prefix": "MinimumnumberofCoins",
	"body": [
	  "",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "",
	  "int minCoins(int coins[], int m, int V)",
	  "{",
	  "",
	  "if (V == 0) return 0;",
	  "",
	  "",
	  "int res = INT_MAX;",
	  "",
	  "",
	  "for (int i=0; i<m; i++)",
	  "{",
	  "if (coins[i] <= V)",
	  "{",
	  "int sub_res = minCoins(coins, m, V-coins[i]);",
	  "",
	  "",
	  "if (sub_res != INT_MAX && sub_res + 1 < res)",
	  "res = sub_res + 1;",
	  "}",
	  "}",
	  "return res;",
	  "}",
	  "",
	  "",
	  "int main()",
	  "{",
	  "int coins[] = {9, 6, 5, 1};",
	  "int m = sizeof(coins)/sizeof(coins[0]);",
	  "int V = 11;",
	  "cout << \"Minimum coins required is \"",
	  "<< minCoins(coins, m, V);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },

  "HappyNumber": {
	"prefix": "HappyNumber",
	"body": [
	  "// method return true if n is Happy Number",
	  "// numSquareSum method is given in below detailed code snippet",
	  "int isHappyNumber(int n)",
	  "{",
	  "set<int> st;",
	  "while (1)",
	  "{",
	  "n = numSquareSum(n);",
	  "if (n == 1)",
	  "return true;",
	  "if (st.find(n) != st.end())",
	  "return false;",
	  "st.insert(n);",
	  "}",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "FactDigitSum": {
	"prefix": "FactDigitSum",
	"body": [
	  "class Solution{",
	  "public:",
	  "vector<int> FactDigit(int N)",
	  "{",
	  "    vector<int> fact(10);",
	  "    fact[0] = 1;",
	  "    ",
	  "    for(int i=1;i<=9;i++) {",
	  "        fact[i] = i*fact[i-1];",
	  "    }",
	  "    ",
	  "    vector<int> tmp;",
	  "    for(int i=9;i>=1;i--) {",
	  "        if(N - fact[i] >= 0) {",
	  "            N -= fact[i];",
	  "            tmp.push_back(i);",
	  "            i++;",
	  "        }",
	  "        if(N == 0) break;",
	  "    }",
	  "    ",
	  "   sort(tmp.begin(),tmp.end());",
	  "    return tmp;",
	  "}",
	  "};"
	],
	"description": "Log output to console"
  },
  
  "PrintN-bitbinarynumbershavingmore1’sthan0’s": {
	"prefix": "PrintN-bitbinarynumbershavingmore1’sthan0’s",
	"body": [
	  "// C++ program to print all N-bit binary",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "/* function to generate n digit numbers*/",
	  "void printRec(string number, int extraOnes,",
	  "int remainingPlaces)",
	  "{",
	  "/* if number generated */",
	  "if (0 == remainingPlaces) {",
	  "cout << number << \" \";",
	  "return;",
	  "}",
	  "",
	  "/* Append 1 at the current number and reduce",
	  "the remaining places by one */",
	  "printRec(number + \"1\", extraOnes + 1,",
	  "remainingPlaces - 1);",
	  "",
	  "/* If more ones than zeros, append 0 to the",
	  "current number and reduce the remaining",
	  "places by one*/",
	  "if (0 < extraOnes)",
	  "printRec(number + \"0\", extraOnes - 1,",
	  "remainingPlaces - 1);",
	  "}",
	  "",
	  "void printNums(int n)",
	  "{",
	  "string str = \"\";",
	  "printRec(str, 0, n);",
	  "}",
	  "",
	  "// Driver code",
	  "int main()",
	  "{",
	  "int n = 4;",
	  "",
	  "// Function call",
	  "printNums(n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Sum-string": {
	"prefix": "Sum-string",
	"body": [
	  "// C++ program to check if a given string",
	  "// is sum-string or not",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "// this is function for finding sum of two",
	  "// numbers as string",
	  "string string_sum(string str1, string str2)",
	  "{",
	  "if (str1.size() < str2.size())",
	  "swap(str1, str2);",
	  "",
	  "int m = str1.size();",
	  "int n = str2.size();",
	  "string ans = \"\";",
	  "",
	  "// sum the str2 with str1",
	  "int carry = 0;",
	  "for (int i = 0; i < n; i++) {",
	  "",
	  "// Sum of current digits",
	  "int ds = ((str1[m - 1 - i] - '0')",
	  "+ (str2[n - 1 - i] - '0') + carry)",
	  "% 10;",
	  "",
	  "carry = ((str1[m - 1 - i] - '0')",
	  "+ (str2[n - 1 - i] - '0') + carry)",
	  "/ 10;",
	  "",
	  "ans = char(ds + '0') + ans;",
	  "}",
	  "",
	  "for (int i = n; i < m; i++) {",
	  "int ds = (str1[m - 1 - i] - '0' + carry) % 10;",
	  "carry = (str1[m - 1 - i] - '0' + carry) / 10;",
	  "ans = char(ds + '0') + ans;",
	  "}",
	  "",
	  "if (carry)",
	  "ans = char(carry + '0') + ans;",
	  "return ans;",
	  "}",
	  "",
	  "// Returns true if two substrings of given",
	  "// lengths of str[beg..] can cause a positive",
	  "// result.",
	  "bool checkSumStrUtil(string str, int beg, int len1,",
	  "int len2)",
	  "{",
	  "",
	  "// Finding two substrings of given lengths",
	  "// and their sum",
	  "string s1 = str.substr(beg, len1);",
	  "string s2 = str.substr(beg + len1, len2);",
	  "string s3 = string_sum(s1, s2);",
	  "",
	  "int s3_len = s3.size();",
	  "",
	  "// if number of digits s3 is greater than",
	  "// the available string size",
	  "if (s3_len > str.size() - len1 - len2 - beg)",
	  "return false;",
	  "",
	  "// we got s3 as next number in main string",
	  "if (s3 == str.substr(beg + len1 + len2, s3_len)) {",
	  "",
	  "// if we reach at the end of the string",
	  "if (beg + len1 + len2 + s3_len == str.size())",
	  "return true;",
	  "",
	  "// otherwise call recursively for n2, s3",
	  "return checkSumStrUtil(str, beg + len1, len2,",
	  "s3_len);",
	  "}",
	  "",
	  "// we do not get s3 in main string",
	  "return false;",
	  "}",
	  "",
	  "// Returns true if str is sum string, else false.",
	  "bool isSumStr(string str)",
	  "{",
	  "int n = str.size();",
	  "",
	  "// choosing first two numbers and checking",
	  "// whether it is sum-string or not.",
	  "for (int i = 1; i < n; i++)",
	  "for (int j = 1; i + j < n; j++)",
	  "if (checkSumStrUtil(str, 0, i, j))",
	  "return true;",
	  "",
	  "return false;",
	  "}",
	  "",
	  "// Driver code",
	  "int main()",
	  "{",
	  "bool result;",
	  "",
	  "result = isSumStr(\"1212243660\");",
	  "cout << (result == 1 ? \"True\\n\" : \"False\\n\");",
	  "",
	  "result = isSumStr(\"123456787\");",
	  "cout << (result == 1 ? \"True\\n\" : \"False\\n\");",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "SistersandCoins": {
	"prefix": "SistersandCoins",
	"body": [
	  "class Solution{",
	  "public: ",
	  "    bool check(int v[],int n,int i,int sum)",
	  "    {",
	  "        if(sum==0)",
	  "        {",
	  "            return true;",
	  "        }",
	  "        if(i>=n)",
	  "        {",
	  "            return false;",
	  "        }",
	  "        if(v[i]>sum)",
	  "        {",
	  "            return check(v,n,i+1,sum);",
	  "        }",
	  "        return check(v,n,i+1,sum) or check(v,n,i+1,sum-v[i]);",
	  "    }",
	  "    int sisterCoin(int v[], int n, int m){",
	  "        int sum=accumulate(v,v+n,0)+m;",
	  "        if(sum%2==1)",
	  "        {",
	  "            return 0;",
	  "        }",
	  "        sum/=2;",
	  "        sum-=m;",
	  "        return check(v,n,0,sum);",
	  "        ",
	  "    }",
	  "};"
	],
	"description": "Log output to console"
  },
  
  "NDigitnumberswithdigitsinincreasingorder": {
	"prefix": "NDigitnumberswithdigitsinincreasingorder",
	"body": [
	  "// C++ program to print all n-digit numbers whose digits",
	  "// are strictly increasing from left to right",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "// Function to print all n-digit numbers whose digits",
	  "// are strictly increasing from left to right.",
	  "// out --> Stores current output number as string",
	  "// start --> Current starting digit to be considered",
	  "void findStrictlyIncreasingNum(int start, string out, int n)",
	  "{",
	  "// If number becomes N-digit, print it",
	  "if (n == 0)",
	  "{",
	  "cout << out << \" \";",
	  "return;",
	  "}",
	  "",
	  "// start from (prev digit + 1) till 9",
	  "for (int i = start; i <= 9; i++)",
	  "{",
	  "// append current digit to number",
	  "string str = out + to_string(i);",
	  "",
	  "// recurse for next digit",
	  "findStrictlyIncreasingNum(i + 1, str, n - 1);",
	  "}",
	  "}",
	  "",
	  "// Driver code",
	  "int main()",
	  "{",
	  "int n = 3;",
	  "findStrictlyIncreasingNum(0, \"\", n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Minimumnumberofstepstoreachagivennumber": {
	"prefix": "Minimumnumberofstepstoreachagivennumber",
	"body": [
	  "// CPP program to find minimum number",
	  "// of steps to reach M from N",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "// Function to find a minimum number",
	  "// of steps to reach M from N",
	  "int Minsteps(int n, int m)",
	  "{",
	  "int ans = 0;",
	  "",
	  "// Continue till m is greater than n",
	  "while(m > n)",
	  "{",
	  "// If m is odd",
	  "if(m&1)",
	  "{",
	  "// add one",
	  "m++;",
	  "ans++;",
	  "}",
	  "",
	  
	  "m /= 2;",
	  "ans++;",
	  "}",
	  "",
	  "// Return the required answer",
	  "return ans + n - m;",
	  "}",
	  "",
	  "// Driver code",
	  "int main()",
	  "{",
	  "int n = 4, m = 6;",
	  "",
	  "cout << Minsteps(n, m);",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "WaterOverflow": {
	"prefix": "WaterOverflow",
	"body": [
	  "// Program to find the amount of water in j-th glass",
	  "// of i-th row",
	  "#include <stdio.h>",
	  "#include <stdlib.h>",
	  "#include <string.h>",
	  "",
	  "// Returns the amount of water in jth glass of ith row",
	  "float findWater(int i, int j, float X)",
	  "{",
	  "// A row number i has maximum i columns. So input",
	  "// column number must be less than i",
	  "if (j > i)",
	  "{",
	  "printf(\"Incorrect Inputn\");",
	  "exit(0);",
	  "}",
	  "",
	  "// There will be i*(i+1)/2 glasses till ith row",
	  "// (including ith row)",
	  "float glass[i * (i + 1) / 2];",
	  "",
	  "// Initialize all glasses as empty",
	  "memset(glass, 0, sizeof(glass));",
	  "",
	  "// Put all water in first glass",
	  "int index = 0;",
	  "glass[index] = X;",
	  "",
	  "// Now let the water flow to the downward glasses",
	  "// till the row number is less than or/ equal to i (given row)",
	  "// correction : X can be zero for side glasses as they have lower rate to fill",
	  "for (int row = 1; row <= i ; ++row)",
	  "{",
	  "// Fill glasses in a given row. Number of",
	  "// columns in a row is equal to row number",
	  "for (int col = 1; col <= row; ++col, ++index)",
	  "{",
	  "// Get the water from current glass",
	  "X = glass[index];",
	  "",
	  "// Keep the amount less than or equal to",
	  "// capacity in current glass",
	  "glass[index] = (X >= 1.0f) ? 1.0f : X;",
	  "",
	  "// Get the remaining amount",
	  "X = (X >= 1.0f) ? (X - 1) : 0.0f;",
	  "",
	  "// Distribute the remaining amount to",
	  "// the down two glasses",
	  "glass[index + row] += X / 2;",
	  "glass[index + row + 1] += X / 2;",
	  "}",
	  "}",
	  "",
	  "// The index of jth glass in ith row will",
	  "// be i*(i-1)/2 + j - 1",
	  "return glass[i*(i-1)/2 + j - 1];",
	  "}",
	  "",
	  "// Driver program to test above function",
	  "int main()",
	  "{",
	  "int i = 2, j = 2;",
	  "float X = 2.0; // Total amount of water",
	  "",
	  "printf(\"Amount of water in jth glass of ith row is: %f\",",
	  "findWater(i, j, X));",
	  "",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  "Expressassumofpowerofnaturalnumbers": {
	"prefix": "Expressassumofpowerofnaturalnumbers",
	"body": [
	  "// C++ program to count number of ways any",
	  "// given integer x can be expressed as n-th",
	  "// power of unique natural numbers.",
	  "#include <bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "// Function to calculate and return the",
	  "// power of any given number",
	  "int power(int num, unsigned int n)",
	  "{",
	  "if (n == 0)",
	  "return 1;",
	  "else if (n % 2 == 0)",
	  "return power(num, n / 2) * power(num, n / 2);",
	  "else",
	  "return num * power(num, n / 2) * power(num, n / 2);",
	  "}",
	  "",
	  "// Function to check power representations recursively",
	  "int checkRecursive(int x, int n, int curr_num = 1,",
	  "int curr_sum = 0)",
	  "{",
	  "// Initialize number of ways to express",
	  "// x as n-th powers of different natural",
	  "// numbers",
	  "int results = 0;",
	  "",
	  "// Calling power of 'i' raised to 'n'",
	  "int p = power(curr_num, n);",
	  "while (p + curr_sum < x) {",
	  "// Recursively check all greater values of i",
	  "results += checkRecursive(x, n, curr_num + 1,",
	  "p + curr_sum);",
	  "curr_num++;",
	  "p = power(curr_num, n);",
	  "}",
	  "",
	  "// If sum of powers is equal to x",
	  "// then increase the value of result.",
	  "if (p + curr_sum == x)",
	  "results++;",
	  "",
	  "// Return the final result",
	  "return results;",
	  "}",
	  "",
	  "// Driver Code.",
	  "int main()",
	  "{",
	  "int x = 10, n = 2;",
	  "cout << checkRecursive(x, n);",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  },
  
  
  "Decodethestring": {
	"prefix": "Decodethestring",
	"body": [
	  "// C++ program to decode a string recursively",
	  "// encoded as count followed substring",
	  "#include<bits/stdc++.h>",
	  "using namespace std;",
	  "",
	  "// Returns decoded string for 'str'",
	  "string decode(string str)",
	  "{",
	  "stack<int> integerstack;",
	  "stack<char> stringstack;",
	  "string temp = \"\", result = \"\";",
	  "",
	  "// Traversing the string",
	  "for (int i = 0; i < str.length(); i++)",
	  "{",
	  "int count = 0;",
	  "",
	  "// If number, convert it into number",
	  "// and push it into integerstack.",
	  "if (str[i] >= '0' && str[i] <='9')",
	  "{",
	  "while (str[i] >= '0' && str[i] <= '9')",
	  "{",
	  "count = count * 10 + str[i] - '0';",
	  "i++;",
	  "}",
	  "",
	  "i--;",
	  "integerstack.push(count);",
	  "}",
	  "",
	  "// If closing bracket ']', pop element until",
	  "// '[' opening bracket is not found in the",
	  "// character stack.",
	  "else if (str[i] == ']')",
	  "{",
	  "temp = \"\";",
	  "count = 0;",
	  "",
	  "if (! integerstack.empty())",
	  "{",
	  "count = integerstack.top();",
	  "integerstack.pop();",
	  "}",
	  "",
	  "while (! stringstack.empty() && stringstack.top()!='[' )",
	  "{",
	  "temp = stringstack.top() + temp;",
	  "stringstack.pop();",
	  "}",
	  "",
	  "if (! stringstack.empty() && stringstack.top() == '[')",
	  "stringstack.pop();",
	  "",
	  "// Repeating the popped string 'temo' count",
	  "// number of times.",
	  "for (int j = 0; j < count; j++)",
	  "result = result + temp;",
	  "",
	  "// Push it in the character stack.",
	  "for (int j = 0; j < result.length(); j++)",
	  "stringstack.push(result[j]);",
	  "",
	  "result = \"\";",
	  "}",
	  "",
	  "// If '[' opening bracket, push it into character stack.",
	  "else if (str[i] == '[')",
	  "{",
	  "if (str[i-1] >= '0' && str[i-1] <= '9')",
	  "stringstack.push(str[i]);",
	  "",
	  "else",
	  "{",
	  "stringstack.push(str[i]);",
	  "integerstack.push(1);",
	  "}",
	  "}",
	  "",
	  "else",
	  "stringstack.push(str[i]);",
	  "}",
	  "",
	  "// Pop all the element, make a string and return.",
	  "while (! stringstack.empty())",
	  "{",
	  "result = stringstack.top() + result;",
	  "stringstack.pop();",
	  "}",
	  "",
	  "return result;",
	  "}",
	  "",
	  "// Driven Program",
	  "int main()",
	  "{",
	  "string str = \"3[b2[ca]]\";",
	  "cout << decode(str) << endl;",
	  "return 0;",
	  "}",
	  ""
	],
	"description": "Log output to console"
  }
}